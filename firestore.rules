firestore
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Users collection rules
    match /users/{userId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.auth.uid == userId; // Ensure the document ID matches the authenticated user's UID on creation
      allow update: if request.auth != null && request.auth.uid == userId; // Allow user to update their own document
      allow delete: if false; // Prevent deletion of user documents via rules for now
    }

    // Farms collection rules
    // Farms are owned by a user, identified by the 'owner_id' field.
    match /farms/{farmId} {
      // Only authenticated users can read farms, with potential public visibility rules added later.
      // For now, allow authenticated users to read farms they own, refine later based on public/private settings.
      allow read: if request.auth != null && request.auth.uid == resource.data.owner_id; 

      // Only authenticated users with the 'farmer' role can create farms.
      // Assumes 'stakeholder_type' is stored in the user document and fetched using get()
      allow create: if request.auth != null 
                       && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.stakeholder_type == 'farmer';

      // Only the owner of the farm (identified by owner_id) can update or delete it.
      allow update: if request.auth != null && request.auth.uid == resource.data.owner_id;
      allow delete: if request.auth != null && request.auth.uid == resource.data.owner_id;
    }

    // Crops collection rules
    // Crops belong to a farm and are implicitly owned by the farm's owner.
    match /crops/{cropId} {
      // Only authenticated users can read crops, refine later based on farm's public/private settings.
 allow read: if request.auth != null && request.auth.uid == resource.data.owner_id;

      // Only authenticated users can create crops, and the crop must belong to a farm they own.
      allow create: if request.auth != null
                       && request.resource.data.owner_id == request.auth.uid; // owner_id must be set to the authenticated user's UID on creation

      // Only the owner of the farm the crop belongs to can update or delete it.
      allow update: if request.auth != null && request.auth.uid == resource.data.owner_id;
      allow delete: if request.auth != null && request.auth.uid == resource.data.owner_id;
    }

    // Shops collection rules
    // Shops are owned by a user, identified by the 'userId' field.
    match /shops/{shopId} {
      allow read: if request.auth != null; // Allow authenticated users to read any shop for now
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId; // User can create a shop linked to their UID
      allow update: if request.auth != null && request.auth.uid == resource.data.userId; // User can update their own shop
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId; // User can delete their own shop
    }

    // Posts collection rules
    match /posts/{postId} {
      allow read: if request.auth != null; // Allow authenticated users to read all posts for now
      allow create: if request.auth != null; // Allow authenticated users to create posts
      allow update: if request.auth != null && request.auth.uid == resource.data.authorId; // Only author can update
      allow delete: if request.auth != null && request.auth.uid == resource.data.authorId; // Only author can delete
    }

    // Comments collection rules
    match /comments/{commentId} {
      allow read: if request.auth != null; // Allow authenticated users to read all comments for now
      allow create: if request.auth != null; // Allow authenticated users to create comments
      allow update: if request.auth != null && request.auth.uid == resource.data.authorId; // Only author can update
      allow delete: if request.auth != null && request.auth.uid == resource.data.authorId; // Only author can delete
    }
    // Likes collection rules
    match /likes/{likeId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      // Allow user to delete their own like, but not update
      allow update: if false;
      allow delete: if request.auth != null && request.auth.uid == resource.data.user_id;
    }

    // Collection Group rules for 'crops' to enable querying across farms owned by a user
    // Note: Collection Group rules are separate from document match rules.
    match /{path=**}/crops/{cropId} {
       allow read: if request.auth != null 
                       && request.auth.uid == resource.data.owner_id; // Allow read if the authenticated user is the owner
    }

    // Orders collection rules
    match /orders/{orderId} {
      // Orders are created by the backend, so no client-side create is allowed
      allow create: if false; 

      // Authenticated users can read an order if they are the buyer or the seller
      allow read: if request.auth != null && (request.auth.uid == resource.data.buyerId || request.auth.uid == resource.data.sellerId);
      
      // Allow updates only if authenticated and based on status and roles (simplified for now)
      // More complex role-based status transitions should be handled in backend functions
      allow update: if request.auth != null && (request.auth.uid == resource.data.buyerId || request.auth.uid == resource.data.sellerId);

      allow delete: if false; // Prevent deletion of orders via rules for now
    }
  }
}